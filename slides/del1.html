<!DOCTYPE html>
<html>
  <head>
    <title>Python-kurs, NTNU, 2012</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <script src="https://github.com/downloads/gnab/remark/remark-0.3.1.min.js" type="text/javascript">
      { "highlightStyle": "solarized_light" }
    </script>
    <script src="../lib/jquery-1.7.1.js" type="text/javascript"></script>
    <script src="../lib/bekk.js" type="text/javascript"></script>

    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

    <link rel="stylesheet/less" type="text/css" href="../lib/bekk.less">
    <script src="http://lesscss.googlecode.com/files/less-1.1.5.min.js" type="text/javascript"></script>
  </head>
  <body>
    <textarea id="source">

.front-page

# Python-kurs

## Del 1: Introduksjon

Forelesning ved NTNU

Åsmund Eldhuset / Håkon Erichsen

29/02/2012

---

.agenda

# Agenda

* Om Python
* Grunnleggende syntaks
* Funksjoner og kontrollflyt
* Lister, tupler og dictionaries
* Løkker
* Fil-IO
* `\*args` og `\*\*kwargs`
* Objektorientering
* Ducktyping

---

# Om Python

* Kjøres av en interpreter

* Dynamisk, sterkt typet

* Konsis og lesbar syntaks

        .python
        print "Hello world!"

---

# Grunnleggende syntaks

* Whitespace _er_ signifikant

    * Innrykket bestemmer nøstingen
    
    * Ingen krøllparenteser
    
* Variabler trenger ikke å deklareres
    
* Ingen semikolon; ett uttrykk per linje

* `print` gir output; `input` venter på at brukeren skriver inn en verdi og gir deg verdien med rett datatype

        .python
        age = input("Please enter your age: ")
        if age >= 20:
            price = age * 5
            print "Welcome - admission is kr.", price
        else:
            print "Get lost!"

---

# Dynamisk og sterk typing

* En variabel har ikke en fast datatype - men _verdien_ en variabel refererer til har det, og man kan ikke uten videre blande typer. Hva man har lov til å gjøre med en variabel bestemmes av verditypen den refererer til.
    
    * Dette er tillatt:
            
            .python
            a = "hei"
            a = 42
    
    * Men ikke dette: 
    
            .python
            a = "42"
            b = 7
            c = a + b
            
    * Kan gjøre eksplisitt konvertering mellom primitive typer: `c = a + str(b)` eller `c = int(a) + b`

---

# Moduler

* Mye funksjonalitet kommer pakket inn i _moduler_. Man kan bruke kode fra en modul ved...

    * ... å importere hele modulen og bruke modulnavnet

            .python
            import math
            print math.sqrt(42)
    * ... å importere akkurat den funksjonen/klassen man trenger
    
            .python
            from math import sqrt
            print sqrt(42)

---

# Oppgave

* Lag et program som ber brukeren om å mate inn tre tall (a, b og c), og så printer den ene løsningen av annengradsligningen ax^2 + bx + c = 0 ved hjelp av formelen a = (b + sqrt(b^2 - 4ac)) / (2a)

    * (Valgfritt) Få programmet til å finne ut om annengradsligningen har én, to eller ingen løsninger, og printer alle de mulige løsningene. Programmet skal altså ikke krasje (men bare printe ingenting) dersom det blir negativt tall under roten.

---

# Lister

* En liste er et utvidbart array

* Kan inneholde elementer av forskjellige typer

* Lages med `[]`:
    
        .python
        a = []          # Tom liste
        b = [4, -2, 7]  # 3 elementer av samme type
        c = ["hei", 2]  # 2 elementer av forskjellig type
        print b         # [4, -2, 7]
        print len(b)    # 3

---

# Lister

    .python
    a = []
    TODO

---

# Tupler

* En tuppel er som en liste som ikke kan endres etter at den er opprettet

* Brukes ofte når man vil returnere mer enn én verdi fra en funksjon

* Lages med `()`:
        
        .python
        t = (2, 9, 5)
        print len(t)    # 3
        print t[2]      # 5
        t.append(7)     # Ikke lov
        t[2] = 8        # Ikke lov

---

# Løkker

* While-løkker fungerer som i Java:

        .python
        number = 35782
        digits = 0
        while number > 0:
            number /= 10
            digits += 1     # ++ finnes ikke

---

# Løkker

* For-løkker i Python fungerer som foreach-løkker i Java: de itererer over en _sekvens_ av elementer (f.eks. en liste)
    
    * Java:
    
            .java
            int[] numbers = new int[] {4, 9, 2, -5, 3};
            for (int x : numbers)
                System.out.println(x);
    
    * Python:
    
            .python
            numbers = [4, 9, 2, -5, 3]
            for x in numbers:
                print x

* Selv om dette lar oss iterere gjennom en liste, får vi ikke vite underveis hvor vi er

---

# Løkker

* Hvordan kan man skrive "vanlige" for-løkker à la Java, som teller indekser fra 0 og oppover?

    * Vi kan bruke `range(n)` eller `xrange(n)`, som skaper en liste med tall fra `0` til `n - 1`:
    
            .python
            print xrange(4)             # [0, 1, 2, 3]
            print len(numbers)          # 5
            print xrange(len(numbers))  # [0, 1, 2, 3, 4]
            # Merk at sistnevnte gir en liste med indeksene til numbers
    
    * Java:
    
            .java
            for (int i = 0; i < numbers.length; i++)
                System.out.println(i + ": " + numbers[i]);
                
    * Python:
    
            .python
            for i in xrange(len(numbers)):
                print i, ":", numbers[i]

---

# Oppgave (lister)

* Lag et program som ber brukeren skrive inn en mengde tall og putter tallene i en liste og...

    * (Enkelt) Printer listen etterpå, ett element per linje (så du kan ikke bare skrive `print numbers`)
    
    * (Middels) Printer det største tallet fra listen (uten å bruke `max()`)
    
    * (Vanskelig) Sorterer listen (uten å bruke `sort()`) og printer den

---

# Dictionaries

* Samme som `Dictionary<Object, Object>` i Java

* Et slags array hvor indeksene ikke trenger å være tall

* Skaper koblinger mellom _nøkler_ (keys) og _verdier_ (values)
    
    * Når man legger en verdi inn i en dictionary, kobler man den til en nøkkel, og ved å oppgi nøkkelen kan man få tilbake verdien
    
    * Hver nøkkel har én verdi knyttet til seg, men den kan byttes ut
    
            .python
            d = {"Ola": 91827364, "Lise": 94128345, "Nils": 41536287}
            d["Kari"] = 46239521    # Legger til en ny nøkkel+verdi
            d["Ola"] = 94238164     # Bytter ut verdien for en eksisterende nøkkel
            print d["Lise"]         # Henter verdien for en nøkkel
            for name in d:          # Itererer gjennom nøklene    
                print name, ":", d[name]

---

# Oppgave (dictionaries)

TODO

---

# Slices

* TODO

---

# `*args` og `**kwargs`

Kan være nyttig å kunne kalle en funksjon med et varierende antall parametere:

    .python
    >>> add(1, 2, 3)
    6
    >>> add(1, 2, 3, 4, 5, 6, 7)
    28
    >>> add(1)
    1

Dette kan vi lage på denne måten:

    def add(*args):
        total = 0
        for arg in args:
            total += arg

        return total

    # Eller enda penere:
    def add(*args):
        return sum(args)

Tuppelen `args` inneholder altså alle overskytende posisjonelle argumenter. Legg merke til `*` som gir variabelen denne magiske betydningen.

---

# `*args` og `**kwargs`

Kan vi gjøre det samme med keyword-arguments?

    .python
    >>> eat(bananas=2, apples=3)
    Omnom, I ate 2 bananas
    Omnom, I ate 3 apples 
    >>> eat(bananas=2, apples=3, oranges=5)
    Omnom, I ate 2 bananas
    Omnom, I ate 3 apples 
    Omnom, I ate 5 oranges 
    >>> eat(cookies=2)
    Omnom, I ate 2 cookies

Dette kan vi lage på denne måten:

    def eat(**kwargs):
        for fruit, number in kwargs.items():
            print "Omnom, I ate %s %s" % (number, fruit)

Dictionaryen `kwargs` inneholder altså alle overskytende keyword-argumenter. Legg merke til at det er `**` som gir variabelen denne magiske betydningen, ikke
navnet `kwargs`, vi kunne like godt skrevet `**food`.

---

# `*args` og `**kwargs`

Kan også kombineres:

    def f1(*args, **kwargs):
        pass

    def f2(bar, *args, **kwargs):
        pass

    def f3(bar, hei=1, *args, **kwargs):
        pass

---

# `*args` og `**kwargs`

### Oppgaver

1\. Lag en funksjon som tar inn et vilkårlig antall posisjonelle variabler, og returnerer gjennomsnittet av dem:
    
    .python
    >>> avg(1, 2, 3)
    2
    >>> avg(1, 1, 1, 3, 14)
    4

2\. Lag en funksjon som printer ut alt den får av argumenter, en på hver linje:

    .python
    >>> print_all(4, 5, 6, lolcat=1)
    4
    5
    6
    lolcat: 1

---

# `*args` og `**kwargs`

Vi kan også gjøre en slags motsatt operasjon:

    def plus(a, b):
        return a + b

    >>> argumenter = [1, 3]
    >>> plus(*argumenter)
    4

Hva skjer her? `*` "pakker ut" listen, og blir det samme som om vi skrev:

    .python
    >>> plus(1, 3)
    4

---

# `*args` og `**kwargs`

Dette kan vi også gjøre med kwargs:

    def plus(a, b):
        return a + b

    >>> argumenter = {'a': 1, 'b': 3}
    >>> plus(**argumenter)
    4

Hva skjer her? `**` "pakker ut" dictionary, og blir det samme som om vi skrev:

    .python
    >>> plus(a=1, b=3)
    4

---

# Objektorientering

    class Animal(object):
        pass

    dog = Animal()
    dog.name = "Tinkerbell"
    dog.legs = 4

Ting vi alltid/ofte har med ved instansiering putter
vi i en constructor, det over kan skrives slik:
    
    class Animal(object):
        def __init__ (self, name, legs):
            self.name = name
            self.legs = legs

    dog = Animal("Tinkerbell", 4)

Legg merke til `self`: samme som *this* i java

---

# Objektorientering

Klasse-variabler kan defineres utenfor `__init__` også:

    class Animal(object):
        hungry = True

        def __init__(self, name, legs):
            self.name = name
            self.legs = legs

        def feed(self, **food):
            self.hungry = False

    >>> dog = Animal("Tinkerbell", 4)
    >>> dog.feed(apples=1)
    >>> dog.hungry
    False
    >>> Animal.hungry
    True

---

# Objektorientering

## Arv

Python har selvfølgelig arv også:

    class Dog(Animal):
        def __init__(self, name, legs=4):
            super(Dog, self).__init__(name, legs)

        def bark(self):
            print "Woof!"

    >>> dog = Dog("Tinkerbell")
    >>> dog.feed(apples=1)
    >>> dog.bark()
    Woof!

---

# Objektorientering

## Flerarv

Dette kan du ikke i Java...

    class Cute(object):
        def cuddle (self):
            print("The %s likes it!" % self.__class__.__name__)

    class Dog(Animal, Cute):
        def __init__(self, name, legs=4):
            super(Dog, self).__init__(name, legs)
        def bark(self):
            print "Woof!"

    >>> dog = Dog("Tinkerbell")
    >>> dog.cuddle()
    The Dog likes it!


---

# Objektorientering

Et ofte brukt mønster ved overstyring (overriding):

    class Dog(Animal, Cute):
        def __init__(self, name, legs=4):
            super(Dog, self).__init__(name, legs)

        def bark(self):
            print "Woof!"

        # Vi overstyrer feed fra Animal:
        def feed(self, **food):
            if 'apples' in food:
                raise TypeError("Dogs don't like apples!")

            super(self, Dog).feed(**food)

---

# Objektorientering

### Oppgave

Kopier koden under:

    class Animal(object):
        hungry = True

        def __init__(self, name, legs):
            self.name = name
            self.legs = legs

        def feed(self, **food):
            self.hungry = False


    class Cute(object):
        def cuddle(self):
            print("The %s likes it!" % self.__class__.__name__)

Lag deretter en ny klasse, `Unicorn`, som arver fra disse to. Akkurat som hunder har de som regel 4 bein.
Men enhjørninger er enda litt særere: 
De spiser bare et partall antall av samme frukt på en gang, og de vil bare kose hvis de er mette.

---

.middle.center

# Ducktyping

_When I see a bird that walks like a duck_

_and swims like a duck and quacks like a duck,_

_I call that bird a duck._

---

.pushed

# This is a duck

![Alt text](images/quak1.jpg)

---

.pushed

# Is this a duck?

![Alt text](images/quak2.jpg)

---

.pushed

# Is this a duck?

![Alt text](images/quak3.jpg)

---

# Ducktyping

Disse bør kunne brukes helt likt:

    class Duck:
        def quack():
            print("quaaaack")

    class Dog:
        def quack():
            print("wooof.. err.. quaaak..")

    class Girl:
        def quack():
            print(":3")

Når man skal bruke en metode: spør om tilgivelse, ikke tillatelse:

    .python
    try:
        obj.quack()
    except (AttributeError, TypeError):
        print(obj + " kunne ikke si et kvekk")

---

# Oppsummering

---

.middle.center

# Spørsmål?

Kom og jobb hos [oss i BEKK](http://www.bekk.no/jobb/stillinger/)

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
