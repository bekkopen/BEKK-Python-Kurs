<!DOCTYPE html>
<html>
  <head>
    <title>Python-kurs, NTNU, 2012</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <script src="https://github.com/downloads/gnab/remark/remark-0.3.1.min.js" type="text/javascript">
      { "highlightStyle": "solarized_light" }
    </script>
    <script src="../lib/jquery-1.7.1.js" type="text/javascript"></script>
    <script src="../lib/bekk.js" type="text/javascript"></script>

    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

    <link rel="stylesheet/less" type="text/css" href="../lib/bekk.less">
    <script src="http://lesscss.googlecode.com/files/less-1.1.5.min.js" type="text/javascript"></script>
  </head>
  <body>
    <textarea id="source">

.front-page

# Python-kurs

## Del 2: Idiomatisk python

Forelesning ved NTNU

Magnus Haug / Kjetil Valle

14/03/2012

---

.agenda

# Agenda

* List comprehension
* Generatorer og iteratorer (teori)
* Generator expressions
* Lambda-funskjoner
* Decorators

---

# List comprehension

List comprehensions er en konsis syntaks for å lage eller transformere lister.
Lar deg enkelt *iterere* over lister og *transformere* og *filtrere* elementene.

Syntaks:

    .python
    resultat = [output for var in list if condition]
    
- `output` er elementene som ender opp i den endelige lista. Her kan vi skrive ut `var` direkte, eller som del av et utrykk.
- `list` kan være referanse til en liste, eller en generator/iterator. Iterering fungerer på samme måte her som i vanlige for-løkker.
- `if condition` kan filtrere bort elementer vi ikke ønsker å få med i resultatet. Dette siste leddet er valgfritt.

---

# List comprehension

### Et enkelt eksempel

Iterér over alle tall fra 0 til 10, filtrer ut de som er større enn 5, og gang disse med -1 før de lagres i en ny liste.

    .python
    resultat = []
    for i in range(10):
        if i > 5:
            resultat.append(-i)

Med list comprehension kan vi i stedet skrive dette som:

    .python
    resultat = [-i for i in range(10) if i > 5]
    
Hva skjer her? Vi itererer `for i in range(10)`, filtrerer `if i > 5`, og transfomerer de resterende elementene til `-i`.

---

# List comprehension

List comprehensions kan også gjøres med nestede løkker:

Eksmpel med 2 nivåer:

    .python
    >>> navn = ['Magnus', 'Kjetil']
    >>> hilsen = ['Hei', 'Hallo', 'HAI']
    >>> [h+' '+n for h in hilsen for n in navn] 
    ['Hei Magnus', 'Hei Kjetil', 'Hallo Magnus', 'Hallo Kjetil', 'HAI Magnus', 'HAI Kjetil']

Eller 5...

    .python
    >>> [str(a)+str(b)+str(c)+str(d)+str(e) for a in range(10) for b in range(10) \
    ... for c in range(10) for d in range(10) for e in range(10)]
    ['00000', '00001', '00002', '00003', ..., '99996', '99997', '99998', '99999']

---

# List comprehension

Fra versjon 2.7 finnes det også tilsvarende syntax for å lage set og dictionaries:

    .python
    >>> [ n*n for n in range(5) ] # vanlig list comprehension
    [0, 1, 4, 9, 16]
    >>>
    >>> { n*n for n in range(5) } # set comprehension
    {0, 1, 4, 16, 9}
    >>>
    >>> { n: n*n for n in range(5) } # dict comprehension
    {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

---

# List comprehension

### Oppgaver

Gjør følgende ved hjelp av list comprehensions:

1. Lag en liste med 2er-potenser: `[2, 4, 8, 16, 32, 64, 128, 256, 512, ...]`
1. Lag dictionary over de samme potensene der nøkkel er `i` og verdi er `2**i`.
1. Lag en liste med alle tall mellom 1 og 100 som er delelig på enten 3 eller 7 men ikke begge.
1. Lag liste med alle oddetall som er multiplikat av et tall mellom 3 og 7 og et tall mellom 10 og 14.
1. Generer gangetabellen for tallene fra 1 til 10 som en 2-dimensjonal liste.

---

# Generatorer og iteratorer

Iteratorer er kanskje verdens kjedeligste konsept, men det er en viktig byggesten.
Flere av de python-elementene vi allerede kjenner fungerer som iteratorer, f.eks. lister:

    .python
    >>> items = [1, 4, 5]
    >>> it = iter(items)
    >>> it.next()
    1
    >>> it.next()
    4
    >>> it.next()
    5
    >>> it.next()
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    StopIteration
    >>>

---

# Generatorer og iteratorer

Syntaktisk sukker

    .python
    >>> items = [1, 4, 5]
    >>> for i in items:
    ...     print i,
    ...
    1 4 5

---

# Generatorer og iteratorer

La oss implementere en iterator selv:

    .python
    class countdown(object):
        def __init__(self,start):
            self.count = start
        def __iter__(self):
            return self
        def next(self):
            if self.count <= 0:
                raise StopIteration
            r = self.count
            self.count -= 1
            return r

Og bruke den:

    .python
    >>> c = countdown(5)
    >>> for i in c:
    ...     print i,
    ...
    5 4 3 2 1

---

# Generatorer og iteratorer

Dette var mye styr, kan det gjøres enklere? Yep, med generatorer:

    .python
    def countdown(i):
        while i > 0:
            yield i
            i -= 1

Resultat:

    .python
    >>> for i in countdown(5):
    ...     print i,
    ...
    5 4 3 2 1

---

# Generatorer og iteratorer

### Hva er nytteverdien?

Uendelige lister, store datamengder:

    .python
    >>> from itertools import count
    >>> c = count()
    >>> c.next()
    0
    >>> c.next()
    1
    >>> c.next()
    2

Spørsmål: Hvordan holder man en uendelig liste i minne?!

---

# Generator expressions

List comprehensions kan automagisk skrives som en generator:

    .python
    >>> liste = [i for i in range(10)]
    >>> generator = (i for i in range(10))
    
    >>> print liste
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    >>> print generator
    <generator object <genexpr> at 0x10ff3e410>
    
    >>> for i in liste:
    ...   print i,
    ... 
    0 1 2 3 4 5 6 7 8 9
    
    >>> for i in liste:
    ...   print i,
    ... 
    0 1 2 3 4 5 6 7 8 9
    
    >>> for i in generator:
    ...   print i,
    ... 
    0 1 2 3 4 5 6 7 8 9
    
    >>> for i in generator:
    ...   print i,
    ... 

Hva skjedde her?

---

# Generator expressions

### Oppgaver:

1. Lag en list comprehension som lister opp alle partall under 20, og print dem

2. Lag et generator expression som gjør det samme. Print dem.

3. Lag et generator expression som lister opp ALLE partall.

4. Print de første 20 av dem, f.eks. slik:  
    `print [alle_partall.next() for i in xrange(20)]`

---

# Lambda-funksjoner

*TODO: Burde vi nevne mer eksplisitt at python har første-klasses funksjoner? (ser ikke ut til at vi var innom det i del 1?) Kanskje noe om nøstede funksjoner også? Og eventuelt noe om variabel-scope og funksjoner?*

Lambdaer er én-linjes funksjoner uten navn:

Vanlig funksjon:

    .python
    >>> def funksjonen_min(num):
    ...     return num*2

    >>> funksjonen_min(3)
    6

Lambda:

    .python
    >>> lambdaen_min = lambda num: num*2
    >>> lambdaen_min(3)
    6

---

# Lambda-funksjoner

Som alle andre funksjoner i Python, kan også lambaer sendes inn som argumenter til andre funksjoner.

    .python
    >>> def double( num ):
    ...     return num * 2
    ... 

    >>> map(double, range(10))
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

Dette blir ofte mer konsist med en lambda:

    .python
    >>> map (lambda num : num * 2, range(10))
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

Akkurat dette tilfellet blir kanskje vel så pent med en list comprehension:

    .python
    >>> [num * 2 for num in range(10)]
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

---

# Lambda-funksjoner

### Oppgaver

TODO

---

# Decorators

En dekorator endrer dynamisk funksjonaliteten av en funksjon uten å måtte endre selve funksjonen.

Syntaksen likner veldig på annotasjoner i Java:

    .python
    @bar_decorator
    def get_foo():
        return "foo"

Eksempelet over er egentlig bare syntaktisk sukker for følgende:

    .python
    def get_foo():
        return "foo"
    get_foo = bar_decorator(get_foo)
    
En dekorator er altså en funksjon* som tar en funksjon som argument og returnerer en ny funksjon.

\* klasser kan også brukes, mer om dette snart…

---

# Decorators


Den enkleste mulige dekoratoren gjør ingenting:

    .python
    def dekorator(fn):
        return fn

Til vanlig oppretter vi en ny funksjon inni dekorator-funksjonen, og returerer denne.

    .python
    def dekorator(fn):
        def ny_fn():
            # Her kan vi gjøre hva vi vil!
            # Vanligvis inkluderer det et kall til fn().
        return ny_fn

I den nye funksjonen kan vi definere funksjonalitet som skal skje før og etter den dekorerte funksjonen kalles. Eller vi kan la være å kalle den i det hele tatt. Eller vi kan endre argumentene den får inn. Eller...

---

# Decorators

### Et enkelt eksempel 

    .python
    >>> def foo(fn):
    ...     def ny_fn():
    ...         print "foo"
    ...         fn()
    ...     return ny_fn
    ... 
    >>> @foo
    ... def bar():
    ...     print "bar"
    ... 
    >>> bar()
    foo
    bar

TODO beskrive hva som skjer

---

# Decorators

For å dekorere funksjoner med ulikt antall argumenter bruker vi * og **.

Eksempel på en dekorator som teller antall argumenter en funksjon får inn:
    
    .python
    >>> def count_args(fn):
    ...     def wrapper_fn(*args, **kwargs):
    ...         antall = len(args) + len(kwargs)
    ...         print "fikk inn %d argumenter" % antall
    ...         fn(*args, **kwargs)
    ...     return wrapper_fn
    ... 
    >>> @count_args
    ... def foo(*args, **kwargs):
    ...     pass
    ... 
    >>> foo()
    fikk inn 0 argumenter
    >>> foo(1, 2, 3)
    fikk inn 3 argumenter
    >>> foo(1, 2, 3, bar="baz")
    fikk inn 4 argumenter
    >>> foo(*range(1000000))
    fikk inn 1000000 argumenter

---

# Decorators

TODO stacking av decorators

    @foo
    @bar
    def baz():
        pass
    
Er det samme som:
        
    def baz()
        pass
    baz = foo(bar(baz))

[wiki](http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators)

---

# Decorators

Man kan gjøre mye fancy med dekoratorer. For flere spenstige eksempler, ta en titt på

* [http://wiki.python.org/moin/PythonDecoratorLibrary](http://wiki.python.org/moin/PythonDecoratorLibrary)

---

# Decorators

### Oppgaver

1. Lag dekoratoren `@deprecated` som skriver ut en advarsel hvis noen bruker den dekorerte funksjonern. Bonus hvis du klarer å inkludere navnet på funksjonen i advarselen.
1. Lag en dekorator som tar tiden på den dekorerte funksjonen. Hint: Du bruker `time()` i modulen `time` for finne tidspunkt.
1. Lag en `@ignore` decorator som gjør at kall til den dekorerte funksjonen ikke lenger gjør noenting.

TODO: moar

---

# Easter Eggs

The Zen of Python

    .python
    import this
    
Hva Python-utviklerne tenker om { og }

    .python
    from __future__ import braces

Alternaltiv implementasjon av Hello World

    import __hello__

Og sist men ikke minst:

    import antigravity

---

# Oppsummering

---

.middle.center

# Spørsmål?

Kom og jobb hos [oss i BEKK](http://www.bekk.no/jobb/stillinger/)

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
